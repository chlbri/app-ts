{"version":3,"file":"toPredicate.cjs","sources":["../../../src/guards/functions/toPredicate.ts"],"sourcesContent":["import { GUARD_TYPE } from '#constants';\nimport type { EventsMap, PromiseeMap, ToEvents } from '#events';\nimport type { GuardConfig } from '#guards';\nimport type { StateExtended } from '#interpreters';\nimport { isDescriber, isString } from '#types';\nimport { reduceFnMap } from '#utils';\nimport { isDefined } from '@bemedev/basifun';\nimport recursive, { type GuardDefUnion } from '@bemedev/boolean-recursive';\nimport type { types } from '@bemedev/types';\nimport type { PredicateMap, PredicateS2 } from '../types';\n\nexport type _ToPredicateF = <\n  E extends EventsMap,\n  P extends PromiseeMap = PromiseeMap,\n  Pc = any,\n  Tc extends types.PrimitiveObject = types.PrimitiveObject,\n>(\n  events: E,\n  promisees: P,\n  guard: GuardConfig,\n  predicates?: PredicateMap<E, P, Pc, Tc>,\n) => {\n  func?:\n    | GuardDefUnion<[StateExtended<Pc, Tc, ToEvents<E, P>>]>\n    | undefined;\n  errors: string[];\n};\n\nexport type ToPredicate_F = <\n  E extends EventsMap,\n  P extends PromiseeMap = PromiseeMap,\n  Pc = any,\n  Tc extends types.PrimitiveObject = types.PrimitiveObject,\n>(\n  events: E,\n  promisees: P,\n  guard: GuardConfig,\n  predicates?: PredicateMap<E, P, Pc, Tc>,\n) => {\n  predicate?: PredicateS2<E, P, Pc, Tc> | undefined;\n  errors: string[];\n};\n\nconst _toPredicate: _ToPredicateF = (\n  events,\n  promisees,\n  guard,\n  predicates,\n) => {\n  const errors: string[] = [];\n\n  if (isDescriber(guard)) {\n    const fn = predicates?.[guard.name];\n    const func = fn ? reduceFnMap(events, promisees, fn) : undefined;\n    if (!func) errors.push(`Predicate (${guard.name}) is not defined`);\n    return { func, errors };\n  }\n\n  if (isString(guard)) {\n    const fn = predicates?.[guard];\n    const func = fn ? reduceFnMap(events, promisees, fn) : undefined;\n    if (!func) errors.push(`Predicate (${guard}) is not defined`);\n    return { func, errors };\n  }\n\n  const makeArray = (guards: GuardConfig[]) => {\n    return guards\n      .map(guard => _toPredicate(events, promisees, guard, predicates))\n      .filter(({ errors: errors1 }) => {\n        const check = errors1.length > 0;\n        if (check) {\n          errors.push(...errors1);\n\n          // Because if it has error, the function is not defined\n          return false;\n        }\n        return true;\n      })\n      .map(({ func }) => func)\n      .filter(isDefined);\n  };\n\n  if (GUARD_TYPE.and in guard) {\n    const and = makeArray(guard.and);\n    const check = and.length < 1;\n    if (check) return { errors };\n\n    return { func: { and }, errors };\n  }\n\n  const or = makeArray(guard.or);\n  const check = or.length < 1;\n  if (check) return { errors };\n\n  return { func: { or }, errors };\n};\n\n/**\n *\n * @param events of type {@linkcode EventsMap} [E], the events map to use for resolving the predicate.\n * @param promisees of type {@linkcode PromiseeMap} [P], the promisees map to use for resolving the predicate.\n * @param guard of type {@linkcode GuardConfig}, the guard configuration to convert to a predicate.\n * @param predicates of type {@linkcode PredicateMap}, the map of predicates containing functions to execute.\n * @returns an object containing the predicate function and any errors encountered during the conversion.\n *\n * @see {@linkcode ToEvents}\n * @see {@linkcode types.PrimitiveObject}\n * @see {@linkcode PredicateS2}\n * @see {@linkcode GuardDefUnion}\n * @see {@linkcode reduceFnMap}\n * @see {@linkcode isDescriber}\n * @see {@linkcode isString}\n * @see {@linkcode isDefined}\n * @see {@linkcode GUARD_TYPE}\n * @see {@linkcode recursive}\n */\nexport const toPredicate: ToPredicate_F = (\n  events,\n  promisees,\n  guard,\n  predicates,\n) => {\n  const { func, errors } = _toPredicate(\n    events,\n    promisees,\n    guard,\n    predicates,\n  );\n\n  if (!func) return { errors };\n\n  return { predicate: recursive(func), errors };\n};\n"],"names":["isDescriber","reduceFnMap","isString","isDefined","GUARD_TYPE"],"mappings":";;;;;;;;;;;;;;AA2CA,MAAM,YAAY,GAAkB,CAClC,MAAM,EACN,SAAS,EACT,KAAK,EACL,UAAU,KACR;IACF,MAAM,MAAM,GAAa,EAAE;AAE3B,IAAA,IAAIA,sBAAW,CAAC,KAAK,CAAC,EAAE;QACtB,MAAM,EAAE,GAAG,UAAU,GAAG,KAAK,CAAC,IAAI,CAAC;AACnC,QAAA,MAAM,IAAI,GAAG,EAAE,GAAGC,6BAAW,CAAC,MAAM,EAAE,SAAS,EAAE,EAAE,CAAC,GAAG,SAAS;AAChE,QAAA,IAAI,CAAC,IAAI;YAAE,MAAM,CAAC,IAAI,CAAC,CAAA,WAAA,EAAc,KAAK,CAAC,IAAI,CAAA,gBAAA,CAAkB,CAAC;AAClE,QAAA,OAAO,EAAE,IAAI,EAAE,MAAM,EAAE;IACzB;AAEA,IAAA,IAAIC,mBAAQ,CAAC,KAAK,CAAC,EAAE;AACnB,QAAA,MAAM,EAAE,GAAG,UAAU,GAAG,KAAK,CAAC;AAC9B,QAAA,MAAM,IAAI,GAAG,EAAE,GAAGD,6BAAW,CAAC,MAAM,EAAE,SAAS,EAAE,EAAE,CAAC,GAAG,SAAS;AAChE,QAAA,IAAI,CAAC,IAAI;AAAE,YAAA,MAAM,CAAC,IAAI,CAAC,cAAc,KAAK,CAAA,gBAAA,CAAkB,CAAC;AAC7D,QAAA,OAAO,EAAE,IAAI,EAAE,MAAM,EAAE;IACzB;AAEA,IAAA,MAAM,SAAS,GAAG,CAAC,MAAqB,KAAI;AAC1C,QAAA,OAAO;AACJ,aAAA,GAAG,CAAC,KAAK,IAAI,YAAY,CAAC,MAAM,EAAE,SAAS,EAAE,KAAK,EAAE,UAAU,CAAC;aAC/D,MAAM,CAAC,CAAC,EAAE,MAAM,EAAE,OAAO,EAAE,KAAI;AAC9B,YAAA,MAAM,KAAK,GAAG,OAAO,CAAC,MAAM,GAAG,CAAC;YAChC,IAAI,KAAK,EAAE;AACT,gBAAA,MAAM,CAAC,IAAI,CAAC,GAAG,OAAO,CAAC;;AAGvB,gBAAA,OAAO,KAAK;YACd;AACA,YAAA,OAAO,IAAI;AACb,QAAA,CAAC;aACA,GAAG,CAAC,CAAC,EAAE,IAAI,EAAE,KAAK,IAAI;aACtB,MAAM,CAACE,iBAAS,CAAC;AACtB,IAAA,CAAC;AAED,IAAA,IAAIC,4BAAU,CAAC,GAAG,IAAI,KAAK,EAAE;QAC3B,MAAM,GAAG,GAAG,SAAS,CAAC,KAAK,CAAC,GAAG,CAAC;AAChC,QAAA,MAAM,KAAK,GAAG,GAAG,CAAC,MAAM,GAAG,CAAC;AAC5B,QAAA,IAAI,KAAK;YAAE,OAAO,EAAE,MAAM,EAAE;QAE5B,OAAO,EAAE,IAAI,EAAE,EAAE,GAAG,EAAE,EAAE,MAAM,EAAE;IAClC;IAEA,MAAM,EAAE,GAAG,SAAS,CAAC,KAAK,CAAC,EAAE,CAAC;AAC9B,IAAA,MAAM,KAAK,GAAG,EAAE,CAAC,MAAM,GAAG,CAAC;AAC3B,IAAA,IAAI,KAAK;QAAE,OAAO,EAAE,MAAM,EAAE;IAE5B,OAAO,EAAE,IAAI,EAAE,EAAE,EAAE,EAAE,EAAE,MAAM,EAAE;AACjC,CAAC;AAED;;;;;;;;;;;;;;;;;;AAkBG;AACI,MAAM,WAAW,GAAkB,CACxC,MAAM,EACN,SAAS,EACT,KAAK,EACL,UAAU,KACR;AACF,IAAA,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,GAAG,YAAY,CACnC,MAAM,EACN,SAAS,EACT,KAAK,EACL,UAAU,CACX;AAED,IAAA,IAAI,CAAC,IAAI;QAAE,OAAO,EAAE,MAAM,EAAE;IAE5B,OAAO,EAAE,SAAS,EAAE,SAAS,CAAC,IAAI,CAAC,EAAE,MAAM,EAAE;AAC/C;;;;"}