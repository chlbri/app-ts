{"version":3,"file":"primitives.js","sources":["../../src/types/primitives.ts"],"sourcesContent":["import type { DEFAULT_DELIMITER } from '#constants';\nimport type { types } from '@bemedev/types';\n\nimport type { EventsMap, PromiseeMap, ToEvents, ToEventsR } from '#events';\nimport type {\n  State,\n  StateExtended,\n  StateP,\n  StatePextended,\n} from '#interpreters';\nimport { checkKeys } from '#utils';\n\nexport type IsString_F = (value: unknown) => value is string;\n\n/**\n * Single or readonly array type of {@linkcode T}.\n */\nexport type SingleOrArrayR<T> = T | readonly T[];\n\n/**\n * Single or readonly array type of {@linkcode T} with at least one element.\n * This type is useful when you want to ensure that the value is either a single\n * element of type {@linkcode T} or an array containing at least one element of\n * type {@linkcode T}.\n */\nexport type SingleOrArrayL<T> = T | readonly [...(readonly T[]), T];\n\n/**\n * Describer keys used to define the name and description of an object.\n */\nexport const DESCRIBER_KEYS = ['name', 'description'] as const;\n\n/**\n * Describer type that contains a name and a description.\n */\nexport type Describer = Record<(typeof DESCRIBER_KEYS)[number], string>;\n\n/**\n * Retrieves the name property from a Describer type.\n */\nexport type FromDescriber<T extends Describer> = T['name'];\n\n/**\n * A {@linkcode Describer} type where the description property is optional.\n */\nexport type Describer2 = types.NOmit<Describer, 'description'> &\n  Partial<Pick<Describer, 'description'>>;\n\nexport const isFunction = (value: unknown): value is types.Fn => {\n  return typeof value === 'function';\n};\n\nexport const isString: IsString_F = value => {\n  return typeof value === 'string';\n};\n\nexport const isDescriber = (arg: any): arg is Describer => {\n  const out = checkKeys(arg, ...DESCRIBER_KEYS);\n  return out;\n};\n\n/**\n * Can be used after\n */\nexport type NotReadonly<T> = {\n  -readonly [P in keyof T]: T[P];\n};\n\n/**\n * Can be used after\n */\nexport type Define<T, U> = T extends undefined\n  ? U\n  : undefined extends T\n    ? types.NotUndefined<T>\n    : T;\n\n/**\n * Option for changing a property access in an object.\n */\ntype ChangePropertyOption =\n  | 'readonly'\n  | 'readonly_undefined'\n  | 'normal'\n  | 'undefined';\n\n/**\n * Changes the property access of a specific property in an object type.\n *\n * @template T - The object type to change.\n * @template name - The name of the property of {@linkcode T} to change.\n * @template replace - The name of the property to replace the original property with.\n * @template : {@linkcode ChangePropertyOption} [option] - The option for changing the property access.\n *\n * @remarks Can be used\n *\n * @see {@linkcode NOmit} for removing a property from an object type.\n */\nexport type ChangeProperty<\n  T extends object,\n  name extends keyof T,\n  replace extends string,\n  option extends ChangePropertyOption = 'normal',\n> = types.NOmit<T, name> &\n  (name extends any\n    ? option extends 'readonly'\n      ? { +readonly [key in replace]: T[name] }\n      : option extends 'readonly_undefined'\n        ? { +readonly [key in replace]+?: T[name] }\n        : option extends 'undefined'\n          ? { [key in replace]+?: T[name] }\n          : { [key in replace]: T[name] }\n    : never);\n\ntype _KeyStrings<\n  T extends object,\n  AddObjectKey extends boolean = true,\n  Key extends keyof T = keyof T,\n> = Key extends string\n  ? types.NotUndefined<T[Key]> extends object\n    ? {\n        [key in keyof T]: (T[key] extends infer T2 extends object\n          ? types.UnionToIntersection<_KeyStrings<T2, AddObjectKey>>\n          : never) &\n          (AddObjectKey extends true\n            ? { [key in HighMy]: string }\n            : NonNullable<object>);\n      }\n    : { [key in Key]: string }\n  : never;\n\nexport type KeyStrings<\n  T extends object,\n  AddObjectKey extends boolean = true,\n  Key extends keyof T = keyof T,\n> = types._UnionToIntersection2<_KeyStrings<T, AddObjectKey, Key>>;\n\nexport type HighMy = '@my';\n\ntype __ChangeProperties<\n  T extends object,\n  U extends types.DeepPartial<KeyStrings<T>> = types.DeepPartial<\n    KeyStrings<T>\n  >,\n> = {\n  [key in keyof T as key extends keyof U\n    ? U[key] extends infer U1\n      ? U1 extends { [key in HighMy]: string }\n        ? U1[HighMy]\n        : U1 extends string\n          ? U1\n          : key\n      : never\n    : key]: key extends keyof U\n    ? T[key] extends infer T1 extends object\n      ? Omit<U[key], HighMy> extends infer U1 extends types.DeepPartial<\n          KeyStrings<T1, true>\n        >\n        ? __ChangeProperties<T1, U1>\n        : never\n      : T[key]\n    : T[key];\n};\n\ntype _ChangeProperties<\n  T extends object,\n  U extends types.DeepPartial<KeyStrings<T>> = types.DeepPartial<\n    KeyStrings<T>\n  >,\n  option extends Extract<\n    ChangePropertyOption,\n    'normal' | 'undefined'\n  > = 'normal',\n> =\n  __ChangeProperties<T, U> extends infer Tn\n    ? option extends 'undefined'\n      ? types.DeepPartial<Tn>\n      : Tn\n    : never;\n\n/**\n * Changes the properties of an object type based on a partial object type.\n *\n * @template T - The object type to change.\n * @template U - The partial object type that defines the changes.\n * @template : {@linkcode ChangePropertyOption} [option] - The option for changing the property access.\n *\n * @remarks This can be usefull after\n *\n * @see {@linkcode DeepPartial} for creating a deep partial type.\n * @see {@linkcode KeyStrings} for creating a type with string keys.\n * @see {@linkcode _ChangeProperties} for changing a single property access.\n */\nexport type ChangeProperties<\n  T extends object,\n  U extends types.DeepPartial<KeyStrings<T>> = types.DeepPartial<\n    KeyStrings<T>\n  >,\n  option extends Extract<\n    ChangePropertyOption,\n    'normal' | 'undefined'\n  > = 'normal',\n> =\n  types.DeepPartial<KeyStrings<T>> extends U\n    ? T\n    : _ChangeProperties<T, U, option>;\n\n/**\n * Remap an object by adding an `__id` property.\n *\n * @template T - The object type to remap.\n */\nexport type Identitfy<T> = T extends object ? T & { __id: string } : T;\n\n/**\n * A helper type to reduce an array type to its element type.\n * It extracts the element type from an array type, whether it is a readonly array or a\n * mutable array.\n *\n * @template T - The type to reduce.\n */\nexport type ReduceArray<T> = T extends readonly (infer U1)[]\n  ? U1\n  : T extends (infer U2)[]\n    ? U2\n    : T;\n\n/**\n * An helper to write common function signatures.\n *\n * @template : {@linkcode EventsMap} [E] - The events map used in the function.\n * @template : {@linkcode PromiseeMap} [P] - The promisees map used in the function.\n * @template Pc - The private context.\n * @template : {@linkcode types.PrimitiveObject} [Tc] - The context of the function, defaults to any object.\n * @template R - The return type of the function, defaults to any.\n *\n * @see {@linkcode ToEvents} for converting events and promisees to a map.\n */\nexport type FnR<\n  E extends EventsMap = EventsMap,\n  P extends PromiseeMap = PromiseeMap,\n  Pc = any,\n  Tc extends types.PrimitiveObject = types.PrimitiveObject,\n  R = any,\n> = (state: StateExtended<Pc, Tc, ToEvents<E, P>>) => R;\n\n/**\n * A helper type to reduce a function signature to its context and events map.\n *\n * @template : {@linkcode EventsMap} [E] - The events map used in the function.\n * @template : {@linkcode PromiseeMap} [P] - The promisees map used in the function.\n * @template : {@linkcode types.PrimitiveObject} [Tc] - The context of the function, defaults to any object.\n * @template R - The return type of the function, defaults to any.\n *\n * @remarks This function signature is a reduced version of {@linkcode FnR} without the private context.\n *\n * @see {@linkcode ToEvents} for converting events and promisees to a map.\n */\nexport type FnReduced<\n  E extends EventsMap = EventsMap,\n  P extends PromiseeMap = PromiseeMap,\n  Tc extends types.PrimitiveObject = types.PrimitiveObject,\n  R = any,\n> = (state: State<Tc, ToEvents<E, P>>) => R;\n\n/**\n * A helper type to reduce a function signature to its context and events map.\n *\n * @template : {@linkcode EventsMap} [E] - The events map used in the function.\n * @template : {@linkcode PromiseeMap} [P] - The promisees map used in the function.\n * @template : {@linkcode types.PrimitiveObject} [Tc] - The context of the function, defaults to any object.\n * @template R - The return type of the function, defaults to any.\n *\n * @see {@linkcode ToEvents} for converting events and promisees to a map.\n * @see {@linkcode FnReduced} for a more generic function signature.\n * @see {@linkcode Extract}\n */\nexport type FnMap2<\n  E extends EventsMap = EventsMap,\n  P extends PromiseeMap = PromiseeMap,\n  Tc extends types.PrimitiveObject = types.PrimitiveObject,\n  R = any,\n  TT extends ToEventsR<E, P> = ToEventsR<E, P>,\n> = {\n  [key in TT['type']]?: (\n    state: StateP<Tc, Extract<TT, { type: key }>['payload']>,\n  ) => R;\n} & {\n  else?: FnReduced<E, P, Tc, R>;\n};\n\nexport type EventToType<T extends string | { type: string }> = T extends {\n  type: infer U extends string;\n}\n  ? U\n  : T extends string\n    ? T\n    : never;\n\ntype _FnMap<\n  E extends EventsMap = EventsMap,\n  P extends PromiseeMap = PromiseeMap,\n  Pc = any,\n  Tc extends types.PrimitiveObject = types.PrimitiveObject,\n  R = any,\n  TT extends ToEvents<E, P> = ToEvents<E, P>,\n> = {\n  [key in EventToType<TT>]?: (\n    state: StatePextended<Pc, Tc, Extract<TT, { type: key }>['payload']>,\n  ) => R;\n} & {\n  else?: FnR<E, P, Pc, Tc, R>;\n};\n\ntype _FnMapR<\n  E extends EventsMap = EventsMap,\n  P extends PromiseeMap = PromiseeMap,\n  Tc extends types.PrimitiveObject = types.PrimitiveObject,\n  R = any,\n  TT extends ToEvents<E, P> = ToEvents<E, P>,\n> = {\n  [key in EventToType<TT>]?: (\n    state: StateP<Tc, Extract<TT, { type: key }>['payload']>,\n  ) => R;\n} & {\n  else?: FnReduced<E, P, Tc, R>;\n};\n\nexport type FnMap<\n  E extends EventsMap = EventsMap,\n  P extends PromiseeMap = PromiseeMap,\n  Pc = any,\n  Tc extends types.PrimitiveObject = types.PrimitiveObject,\n  R = any,\n> = FnR<E, P, Pc, Tc, R> | _FnMap<E, P, Pc, Tc, R, ToEvents<E, P>>;\n\nexport type FnMapR<\n  E extends EventsMap = EventsMap,\n  P extends PromiseeMap = PromiseeMap,\n  Tc extends types.PrimitiveObject = types.PrimitiveObject,\n  R = any,\n> = FnReduced<E, P, Tc, R> | _FnMapR<E, P, Tc, R, ToEvents<E, P>>;\n\n/**\n * A type that represents a record with string keys and values of type {@linkcode T}.\n *\n * @see {@linkcode Record} for more details.\n */\nexport type RecordS<T> = Record<string, T>;\n\n/**\n * A type that represents all values of type {@linkcode T},\n *\n * @see {@linkcode NotUndefined}\n */\nexport type ValuesOf<T> = types.NotUndefined<\n  types.NotUndefined<T>[keyof types.NotUndefined<T>]\n>;\n\n/**\n * A type that represents a record with string keys and values of type {@linkcode R}.\n *\n * @template S - The string keys of the record.\n * @template R - The type of the values in the record, optional\n *\n * @see {@linkcode Record} for more details.\n * @remarks Simplified version of {@linkcode Record}\n */\nexport type KeyU<S extends string, R = unknown> = Record<S, R>;\n\n/**\n * The partial version of {@linkcode KeyU}.\n *\n * @template S - The string keys of the record.\n * @template R - The type of the values in the record, optional\n *\n * @see {@linkcode Partial}\n */\nexport type KeyO<S extends string, R = unknown> = Partial<KeyU<S, R>>;\n\n/**\n * Extracts the string type from a union type {@linkcode T}.\n *\n * @template T - The union type to extract the string type from.\n *\n * @see {@linkcode Extract} for more details.\n */\nexport type ExtractS<T> = Extract<T, string>;\n\n/**\n * A type that represents a true object, which is an object that does not have\n * any iterable properties or the `SymbolConstructor` property.\n *\n * @remarks This type is useful to ensure that the object is a plain object\n * without any special properties.\n *\n * @see {@linkcode Ru} for a utility type that represents a true object.\n * @see {@linkcode SymbolConstructor} for the symbol constructor type.\n */\nexport type TrueObject = types.Ru & {\n  [Symbol.iterator]?: never;\n  //@ts-expect-error - 'SymbolConstructor' does not exist on type 'object'\n  [SymbolConstructor]?: never;\n};\n\n/**\n * A type that represents a not defined.\n *\n * @remarks This type is useful when you want to allow a value to be absent or\n * explicitly set to `null` or `undefined`.\n *\n * @remarks Can be usefull after.\n *\n */\nexport type NoValue = void | undefined | null;\n\nexport type Delimiter = typeof DEFAULT_DELIMITER;\n"],"names":[],"mappings":";;;;;;;;;AA2BA;;AAEG;MACU,cAAc,GAAG,CAAC,MAAM,EAAE,aAAa;AAkB7C,MAAM,UAAU,GAAG,CAAC,KAAc,KAAuB;AAC9D,IAAA,OAAO,OAAO,KAAK,KAAK,UAAU;AACpC;AAEO,MAAM,QAAQ,GAAe,KAAK,IAAG;AAC1C,IAAA,OAAO,OAAO,KAAK,KAAK,QAAQ;AAClC;AAEO,MAAM,WAAW,GAAG,CAAC,GAAQ,KAAsB;IACxD,MAAM,GAAG,GAAG,SAAS,CAAC,GAAG,EAAE,GAAG,cAAc,CAAC;AAC7C,IAAA,OAAO,GAAG;AACZ;;;;"}