{"version":3,"file":"subscriber.cjs","sources":["../../src/interpreters/subscriber.ts"],"sourcesContent":["import type { EventsMap, PromiseeMap, ToEvents } from '#events';\nimport { nothing, toEventsMap } from '#utils';\nimport type { TimerState } from '@bemedev/interval2';\nimport type { types } from '@bemedev/types';\nimport { castings } from '@bemedev/types';\nimport equal from 'fast-deep-equal';\nimport { nanoid } from 'nanoid';\nimport { isFunction } from '../types/primitives';\nimport type { FnSubReduced, State } from './interpreter.types';\n\n/**\n * Subscriber class that manages the subscription state and provides methods\n * to handle state changes and unsubscribe.\n *\n * @template : {@linkcode EventsMap} [E] - Type of the events map\n * @template : {@linkcode PromiseeMap} [P] - Type of the promisees map\n * @template : {@linkcode types.PrimitiveObject} [Tc] - Type of the context\n * @template : [R] - Type of the return value\n *\n */\nclass SubscriberClass<\n  E extends EventsMap,\n  P extends PromiseeMap = PromiseeMap,\n  Tc extends types.PrimitiveObject = types.PrimitiveObject,\n> {\n  #subscriber: FnSubReduced<E, P, Tc, void>;\n\n  #eventsMap: E;\n\n  #promiseesMap: P;\n\n  #state: TimerState = 'idle';\n\n  /**\n   * Function to compare two {@linkcode State}s for equality.\n   * @param previous of type {@linkcode State} - First state to compare\n   * @param next of type {@linkcode State} - Second state to compare\n   */\n  #equals: (previous: State<Tc>, next: State<Tc>) => boolean;\n\n  get id() {\n    return this._id;\n  }\n\n  /**\n   * Creates an instance of SubscriberMapClass.\n   * @param eventsMap - {@linkcode EventsMap} [E] - The events map.\n   * @param promiseesMap - {@linkcode PromiseeMap} [P] - The promisees map.\n   * @param subscriber - The {@linkcode FnSubReduced} subscriber function or object.\n   * @param equals - Function to compare two {@linkcode State}s for equality (optional).\n   * @param _id - Unique identifier for the subscriber (optional).\n   */\n  constructor(\n    eventsMap: E,\n    promiseesMap: P,\n    subscriber: FnSubReduced<E, P, Tc, void>,\n    equals: (a: State<Tc>, b: State<Tc>) => boolean = equal,\n    private _id = nanoid(),\n  ) {\n    this.#subscriber = subscriber;\n    this.#eventsMap = eventsMap;\n    this.#promiseesMap = promiseesMap;\n    this.#equals = equals;\n\n    this.#state = 'active';\n  }\n\n  /**\n   * Function that returns a reduced function based on the subscriber's logic.\n   * @returns A function that reduces the state based on the subscriber's logic.\n   *\n   * @see {@linkcode isFunction} to check if the subscriber is a function.\n   * @see {@linkcode toEventsMap} to convert the events and promisees maps\n   * to a unified map.\n   * @see {@linkcode nothing} to provide a default action if no event matches.\n   * @see {@linkcode t} to ensure type safety in the returned function.\n   */\n  get #reduceFn() {\n    const sub = this.#subscriber;\n    const check1 = isFunction(sub);\n    if (check1) return castings.commons.any(sub);\n\n    const map = toEventsMap(this.#eventsMap, this.#promiseesMap);\n    const keys = Object.keys(map);\n\n    return ({ event, ...rest }: State<Tc, ToEvents<E, P>>) => {\n      const check5 = typeof event === 'string';\n      const _else = sub.else ?? nothing;\n      if (check5) return castings.commons.any(_else({ event, ...rest }));\n\n      const { type, payload } = event;\n\n      for (const key of keys) {\n        const check2 = type === key;\n        const func = castings.commons.any(sub)[key];\n        const check3 = !!func;\n\n        const check4 = check2 && check3;\n        if (check4) return func({ payload, ...rest });\n      }\n\n      return castings.commons.any(_else({ event, ...rest }));\n    };\n  }\n\n  get #cannotPerform() {\n    return !(this.#state === 'active');\n  }\n\n  /**\n   * Function to handle state changes.\n   * @param previous of type {@linkcode State} - Previous state\n   * @param next of type {@linkcode State} - Next state\n   *\n   * @remarks\n   * This function checks if the subscriber can perform its action,\n   * compares the previous and next states using the provided equality function,\n   * and if they are not equal, it calls the subscriber with the next state.\n   * If the states are equal or if the subscriber cannot perform its action,\n   */\n  fn = (previous: State<Tc>, next: State<Tc>) => {\n    if (this.#cannotPerform) return;\n\n    const _equals = this.#equals(previous, next);\n    if (_equals) return;\n\n    return this.#reduceFn(next);\n  };\n\n  /* v8 ignore next 3*/\n  get state() {\n    return this.#state;\n  }\n\n  close = () => {\n    if (this.state !== 'disposed') this.#state = 'paused';\n  };\n\n  open = () => {\n    if (this.state !== 'disposed') this.#state = 'active';\n  };\n\n  unsubscribe = () => {\n    this.close();\n    this.#state = 'disposed';\n  };\n}\n\nexport type { SubscriberClass };\n\nexport type SubscriberOptions<\n  Tc extends types.PrimitiveObject = types.PrimitiveObject,\n> = {\n  id?: string;\n  equals?: (a: State<Tc>, b: State<Tc>) => boolean;\n};\n\ntype CreateSubscriber_F = <\n  E extends EventsMap,\n  P extends PromiseeMap = PromiseeMap,\n  Tc extends types.PrimitiveObject = types.PrimitiveObject,\n>(\n  eventsMap: E,\n  promiseesMap: P,\n  subscriber: FnSubReduced<E, P, Tc, void>,\n  options?: SubscriberOptions<Tc>,\n) => SubscriberClass<E, P, Tc>;\n\n/**\n * Creates a new instance of SubscriberMapClass.\n *\n * @param eventsMap : {@linkcode EventsMap} [E] - The events map.\n * @param promiseesMap : {@linkcode PromiseeMap} [P] - The promisees map.\n * @param subscriber - The subscriber function that will be called with the {@linkcode State}.\n * @param options - Optional parameters for the subscriber, including equality function and ID.\n * @returns A new instance of {@linkcode SubscriberClass} that manages the subscription state and provides methods to handle state changes and unsubscribe.\n *\n * @remarks\n * This function maps the provided events and promisees.\n *\n * This allows for efficient subscription management and state handling depending on the events and promisees.\n */\nexport const createSubscriber: CreateSubscriber_F = (\n  eventsMap,\n  promiseesMap,\n  subscriber,\n  options,\n) => {\n  return new SubscriberClass(\n    eventsMap,\n    promiseesMap,\n    subscriber,\n    options?.equals,\n    options?.id,\n  );\n};\n"],"names":["nanoid","isFunction","castings","toEventsMap","nothing"],"mappings":"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"}