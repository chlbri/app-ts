{"version":3,"file":"resolve.cjs","sources":["../../src/utils/resolve.ts"],"sourcesContent":["import { DEFAULT_DELIMITER } from '#constants';\n\n/**\n * Resolves a relative path against a base path, similar to path.resolve but without dependencies\n * @param basePath - The base path to resolve from\n * @param relativePath - The relative path to resolve\n * @returns The resolved absolute path\n *\n * @example\n * resolve('/parent/child/grandchild/grantchild', '../grandchild')\n * // returns '/parent/child/grandchild'\n *\n * resolve('/parent/child/grandchild/grantchild', '../../grandchild')\n * // returns '/parent/child/grandchild'\n */\nexport function resolve(basePath: string, relativePath: string): string {\n  if (relativePath === DEFAULT_DELIMITER) return DEFAULT_DELIMITER;\n\n  // Normalize paths by removing trailing slashes for processing\n  const normalizedBase = basePath.replace(/\\/+$/, '');\n  const normalizedRelative = relativePath.replace(/\\/+$/, '');\n\n  // Split base path into segments - treat the last segment as a file\n  const baseSegments = normalizedBase\n    .split(DEFAULT_DELIMITER)\n    .filter(segment => segment !== '');\n\n  // Split relative path into segments\n  const relativeSegments = normalizedRelative\n    .split(DEFAULT_DELIMITER)\n    .filter(segment => segment !== '');\n\n  // Check if the original relative path ended with a slash (means directory, not file)\n  const endsWithSlash = relativePath.endsWith(DEFAULT_DELIMITER);\n\n  // Check if the relative path starts with './' - this means we want to join to the current directory\n  const startsWithCurrentDir = relativePath.startsWith('./');\n\n  // Start with base segments minus the last one (since it's treated as a file)\n  // UNLESS the relative path starts with './' which means we want to treat base as a directory\n  const resultSegments = startsWithCurrentDir\n    ? [...baseSegments]\n    : baseSegments.slice(0, -1);\n\n  // Count the number of '..' segments\n  let parentLevels = 0;\n  const nonParentSegments = [];\n\n  for (const segment of relativeSegments) {\n    if (segment === '..') {\n      parentLevels++;\n    } else if (segment !== '.') {\n      nonParentSegments.push(segment);\n    }\n  }\n\n  // Remove parent levels from result\n  for (let i = 0; i < parentLevels; i++) {\n    if (resultSegments.length > 0) {\n      resultSegments.pop();\n    }\n  }\n\n  // Special handling for when no specific target is mentioned\n  if (\n    relativeSegments.length === 0 ||\n    (relativeSegments.length === 1 && relativeSegments[0] === '.') ||\n    normalizedRelative === '.' ||\n    normalizedRelative === ''\n  ) {\n    // Return the original file path\n    return normalizedBase;\n  }\n\n  // If we have only parent navigation (..) and no specific target\n  if (nonParentSegments.length === 0 && parentLevels > 0) {\n    // For cases like '..' or '../../', we need to include the directory name\n    // that we're at after the parent navigation\n    if (resultSegments.length >= 0) {\n      // We want the directory name that we land on after going up\n      // For example: from /parent/child/grandchild/grantchild with '..'\n      // we go to /parent/child and we want to include 'grandchild'\n      // So we need to add one level back down\n      const originalBaseSegments = baseSegments.slice(0, -1);\n      const targetLevel = originalBaseSegments.length - parentLevels;\n      if (targetLevel >= 0 && targetLevel < originalBaseSegments.length) {\n        const targetDir = originalBaseSegments[targetLevel];\n        return (\n          DEFAULT_DELIMITER +\n          resultSegments.join(DEFAULT_DELIMITER) +\n          (resultSegments.length > 0 ? DEFAULT_DELIMITER : '') +\n          targetDir\n        );\n      }\n    }\n    return DEFAULT_DELIMITER + resultSegments.join(DEFAULT_DELIMITER);\n  }\n\n  // Add non-parent segments to result\n  resultSegments.push(...nonParentSegments);\n\n  // Special handling: if the final segment in relative path exists in the original base path,\n  // try to find the best match by looking for that segment in the base path\n  if (\n    nonParentSegments.length > 0 &&\n    !endsWithSlash &&\n    !startsWithCurrentDir\n  ) {\n    const finalSegment = nonParentSegments[nonParentSegments.length - 1];\n    const originalBaseSegments = baseSegments.slice(0, -1); // Directory path of the base\n\n    // Check if the final segment exists in the base path\n    const segmentIndex = originalBaseSegments.indexOf(finalSegment);\n    if (segmentIndex !== -1) {\n      // If found, check if this would be a better resolution\n      const alternativeResult = originalBaseSegments.slice(\n        0,\n        segmentIndex + 1,\n      );\n\n      // Use the alternative if it makes more sense (contains the segment we're looking for)\n      if (\n        alternativeResult.length > resultSegments.length ||\n        (alternativeResult.length === resultSegments.length &&\n          alternativeResult[alternativeResult.length - 1] === finalSegment)\n      ) {\n        return (\n          DEFAULT_DELIMITER + alternativeResult.join(DEFAULT_DELIMITER)\n        );\n      }\n    }\n  }\n\n  // Join segments back with leading slash\n  return DEFAULT_DELIMITER + resultSegments.join(DEFAULT_DELIMITER);\n}\n"],"names":["DEFAULT_DELIMITER"],"mappings":"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"}