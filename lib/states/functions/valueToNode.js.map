{"version":3,"file":"valueToNode.js","sources":["../../../src/states/functions/valueToNode.ts"],"sourcesContent":["import { DEFAULT_DELIMITER } from '#constants';\nimport { isString } from '#types';\nimport { replaceAll } from '#utils';\nimport { decomposeSV, type StateValue } from '@bemedev/decompose';\n\nimport type { NodeConfig } from '../types';\nimport { flatMap } from './flatMap';\nimport { getChildren } from './getChildren';\nimport { getParents } from './getParents';\nimport { recomposeConfig } from './recompose';\n\nexport type ValueToNode_F = <T extends StateValue>(\n  body: NodeConfig,\n  from: T,\n  initial?: boolean,\n) => NodeConfig;\n\n/**\n * Converts a state value to a node configuration based on the provided body and from value.\n *\n * @param body - The node configuration body to convert from.\n * @param from - The state value to convert to a node configuration.\n * @param initial - Optional flag to indicate if the initial state should be included.\n * @returns A node configuration object that represents the state value.\n *\n * @see {@linkcode ValueToNode_F} for more details\n * @see {@linkcode flatMap} for flattening the node configuration\n * @see {@linkcode getChildren} for retrieving child states\n * @see {@linkcode getParents} for retrieving parent states\n * @see {@linkcode recomposeConfig} for recomposing the node configuration\n * @see {@linkcode decomposeSV} for decomposing state values\n * @see {@linkcode replaceAll} for replacing substrings in the state value\n * @see {@linkcode DEFAULT_DELIMITER} for the default delimiter used in state paths\n */\nexport const valueToNode: ValueToNode_F = (body, from) => {\n  const flatBody = flatMap(body as NodeConfig, false);\n  const keysFlatBody = Object.keys(flatBody);\n  const fromIsString = isString(from);\n  if (fromIsString) {\n    const check2 = keysFlatBody.includes(from);\n    if (check2) {\n      const parents = getParents(from as any);\n      const children = getChildren(from, ...keysFlatBody);\n\n      const out1: any = {};\n\n      parents.concat(children).forEach(key => {\n        out1[key] = (flatBody as any)[key];\n      });\n\n      const out: any = recomposeConfig(out1);\n      return out;\n    }\n    return {};\n  }\n\n  const flatFrom = decomposeSV(from)\n    .map(key =>\n      replaceAll({\n        entry: key,\n        match: '.',\n        replacement: DEFAULT_DELIMITER,\n      }),\n    )\n    .map(key => `/${key}`);\n\n  const out1: any = {};\n\n  flatFrom.forEach((key1, _, all) => {\n    const check4 = keysFlatBody.some(key => key.startsWith(key1));\n\n    if (check4) {\n      out1[key1] = (flatBody as any)[key1];\n\n      const initial = (flatBody as any)[key1].initial;\n      if (initial) {\n        const _initial = `${key1}${DEFAULT_DELIMITER}${initial}`;\n        const cannotContinue = all.some(key =>\n          key.startsWith(`${key1}${DEFAULT_DELIMITER}`),\n        );\n        if (cannotContinue) return;\n        out1[_initial] = (flatBody as any)[_initial];\n      }\n    }\n  });\n\n  const out2 = recomposeConfig(out1);\n  return out2;\n};\n"],"names":[],"mappings":";;;;;;;;;;;;;;;AAiBA;;;;;;;;;;;;;;;;AAgBG;MACU,WAAW,GAAkB,CAAC,IAAI,EAAE,IAAI,KAAI;IACvD,MAAM,QAAQ,GAAG,OAAO,CAAC,IAAkB,EAAE,KAAK,CAAC;IACnD,MAAM,YAAY,GAAG,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC;AAC1C,IAAA,MAAM,YAAY,GAAG,QAAQ,CAAC,IAAI,CAAC;IACnC,IAAI,YAAY,EAAE;QAChB,MAAM,MAAM,GAAG,YAAY,CAAC,QAAQ,CAAC,IAAI,CAAC;QAC1C,IAAI,MAAM,EAAE;AACV,YAAA,MAAM,OAAO,GAAG,UAAU,CAAC,IAAW,CAAC;YACvC,MAAM,QAAQ,GAAG,WAAW,CAAC,IAAI,EAAE,GAAG,YAAY,CAAC;YAEnD,MAAM,IAAI,GAAQ,EAAE;YAEpB,OAAO,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,OAAO,CAAC,GAAG,IAAG;gBACrC,IAAI,CAAC,GAAG,CAAC,GAAI,QAAgB,CAAC,GAAG,CAAC;AACpC,YAAA,CAAC,CAAC;AAEF,YAAA,MAAM,GAAG,GAAQ,eAAe,CAAC,IAAI,CAAC;AACtC,YAAA,OAAO,GAAG;QACZ;AACA,QAAA,OAAO,EAAE;IACX;AAEA,IAAA,MAAM,QAAQ,GAAG,WAAW,CAAC,IAAI;AAC9B,SAAA,GAAG,CAAC,GAAG,IACN,UAAU,CAAC;AACT,QAAA,KAAK,EAAE,GAAG;AACV,QAAA,KAAK,EAAE,GAAG;AACV,QAAA,WAAW,EAAE,iBAAiB;AAC/B,KAAA,CAAC;SAEH,GAAG,CAAC,GAAG,IAAI,CAAA,CAAA,EAAI,GAAG,CAAA,CAAE,CAAC;IAExB,MAAM,IAAI,GAAQ,EAAE;IAEpB,QAAQ,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,CAAC,EAAE,GAAG,KAAI;AAChC,QAAA,MAAM,MAAM,GAAG,YAAY,CAAC,IAAI,CAAC,GAAG,IAAI,GAAG,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;QAE7D,IAAI,MAAM,EAAE;YACV,IAAI,CAAC,IAAI,CAAC,GAAI,QAAgB,CAAC,IAAI,CAAC;YAEpC,MAAM,OAAO,GAAI,QAAgB,CAAC,IAAI,CAAC,CAAC,OAAO;YAC/C,IAAI,OAAO,EAAE;gBACX,MAAM,QAAQ,GAAG,CAAA,EAAG,IAAI,GAAG,iBAAiB,CAAA,EAAG,OAAO,CAAA,CAAE;gBACxD,MAAM,cAAc,GAAG,GAAG,CAAC,IAAI,CAAC,GAAG,IACjC,GAAG,CAAC,UAAU,CAAC,CAAA,EAAG,IAAI,GAAG,iBAAiB,CAAA,CAAE,CAAC,CAC9C;AACD,gBAAA,IAAI,cAAc;oBAAE;gBACpB,IAAI,CAAC,QAAQ,CAAC,GAAI,QAAgB,CAAC,QAAQ,CAAC;YAC9C;QACF;AACF,IAAA,CAAC,CAAC;AAEF,IAAA,MAAM,IAAI,GAAG,eAAe,CAAC,IAAI,CAAC;AAClC,IAAA,OAAO,IAAI;AACb;;;;"}